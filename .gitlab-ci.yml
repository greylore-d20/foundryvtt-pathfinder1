image: node

variables:
  PACKAGE_NAME: pf1
  PACKAGE_TYPE: system
  PACKAGE_REGISTRY_URL: $CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME

stages:
  - check
  - build
  - prepare-release
  - release
  - publish

# Anchor variable to install npm cache
cache: &global_cache
  paths:
    - .npm

# Anchor script to install package dependencies with npm ci, using cache
.npm-ci: &npm-ci
  - npm ci --cache .npm --prefer-offline

# Run ESLint in error-only mode
lint:
  stage: check
  before_script:
    - *npm-ci
  script:
    - npm run lint:ci
  cache:
    <<: *global_cache

# Run prettier check
format:
  stage: check
  before_script:
    - *npm-ci
  script:
    - npm run format:check
  cache:
    <<: *global_cache

# Generate manifest links, build dist directory
build:
  stage: build
  before_script:
    - *npm-ci
    - apt-get --yes update
    - apt-get --yes install jq
  script:
    - TEMP_MANIFEST=$(mktemp)
    - |
      jq '.version = $version | .url = $url | .manifest = $manifest | .download = $download' \
      --arg version "${CI_COMMIT_TAG:1}" \
      --arg url "$CI_PROJECT_URL" \
      --arg manifest "$CI_PROJECT_URL/-/releases/permalink/latest/downloads/$PACKAGE_TYPE.json" \
      --arg download "$CI_PROJECT_URL/-/releases/$CI_COMMIT_TAG/downloads/$PACKAGE_NAME.zip" \
      $PACKAGE_TYPE.json > $TEMP_MANIFEST
    - mv $TEMP_MANIFEST $PACKAGE_TYPE.json
    - npm run build
  cache:
    <<: *global_cache
  artifacts:
    paths:
      - dist
    expire_in: 1 week
  # Run for version tags to prepare release, and for MRs to check successful build
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Publish artifacts to package registry and generate release notes from changelog
# Link for regex: https://regex101.com/r/OyDskw/1, has to be verified manually in ripgrep
publish_artifacts:
  stage: prepare-release
  image: alpine:latest
  before_script:
    - apk update
    - apk add zip curl ripgrep
  script: |
    cd dist
    zip -r ../$PACKAGE_NAME.zip .
    cd ..
    curl --header "JOB-TOKEN: $CI_JOB_TOKEN" --upload-file $PACKAGE_NAME.zip "$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_NAME.zip"
    curl --header "JOB-TOKEN: $CI_JOB_TOKEN" --upload-file dist/$PACKAGE_TYPE.json "$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_TYPE.json"
    echo "**Manifest URL:** $CI_PROJECT_URL/-/releases/$CI_COMMIT_TAG/downloads/$PACKAGE_TYPE.json" > recent-changes.md
    echo "" >> recent-changes.md
    echo "$(rg -U --multiline-dotall '(?P<latest>^[#]{2}\sv?\d.*?)(?:\n^[#]{1,3}\sv?\d.*)' -r '$latest' CHANGELOG.md)" >> recent-changes.md
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
  artifacts:
    paths:
      - recent-changes.md
    expire_in: 1 week

# Create release on GitLab, including release notes and attached links to the zip file and this version's manifest
release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - publish_artifacts
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/'
  script:
    - |
      release-cli create --name "Release ${CI_COMMIT_TAG:1}" \
                          --description "$(cat recent-changes.md)" --tag-name $CI_COMMIT_TAG \
                          --assets-link "{\"name\":\"$PACKAGE_NAME.zip\",\"url\":\"$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_NAME.zip\",\"filepath\":\"/$PACKAGE_NAME.zip\",\"link_type\":\"package\"}" \
                          --assets-link "{\"name\":\"$PACKAGE_TYPE.json\",\"url\":\"$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_TYPE.json\",\"filepath\":\"/$PACKAGE_TYPE.json\",\"link_type\":\"other\"}"
