_id: 7Nc1EI6MutYJ716I
_key: '!macros!7Nc1EI6MutYJ716I'
command: "// Author: @Adam\n\n// SETUP NEEDED: for each transformation option you want, please enter it as below\n// you also need to set imageFolder to the location of where you store your tokens.\n// token art is selected by name & as a png, so for example the image for Bat is located at \"worlds/golarion/tokens/Bestiary/Bat.png\"\n\n// support for elemental body is not complete yet - only air elemental is hardcoded\n\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\n\nconst transformationOptions = {\n\tBat: {\n\t\tsize: \"diminutive\",\n\t\tspellSource: \"beast shape\",\n\t},\n\t\"Giant Squid\": {\n\t\tsize: \"huge\",\n\t\tspellSource: \"beast shape\",\n\t},\n\tTendriculos: {\n\t\tsize: \"huge\",\n\t\tspellSource: \"plant shape\",\n\t},\n\t\"Air Elemental\": {\n\t\tsize: \"huge\",\n\t\tspellSource: \"elemental body\",\n\t},\n};\n\nconst sizes = [\n\t\"diminutive\",\n\t\"tiny\",\n\t\"small\",\n\t\"medium\",\n\t\"large\",\n\t\"huge\",\n\t\"gargantuan\",\n\t\"colossal\",\n];\n\nconst sizeTranslation = {\n\tfine: \"fine\",\n\tdiminutive: \"dim\",\n\ttiny: \"tiny\",\n\tsmall: \"sm\",\n\tmedium: \"med\",\n\tlarge: \"lg\",\n\thuge: \"huge\",\n\tgargantuan: \"grg\",\n\tcolossal: \"col\",\n};\n\nconst createSizeObject = ({ w, h, scale }) => {\n\treturn {\n\t\twidth: w,\n\t\theight: h,\n\t\tscale,\n\t};\n};\n\nconst mediumOrBigger = (size) => {\n\treturn sizes.indexOf(size) >= sizes.indexOf(\"medium\");\n};\n\nconst createAbilityChange = (formula, subTarget) => {\n\tformula = \"\" + formula;\n\treturn {\n\t\tformula,\n\t\tpriority: 1,\n\t\ttarget: \"ability\",\n\t\tsubTarget,\n\t\tmodifier: \"size\",\n\t};\n};\n\nconst createNACChange = (formula) => {\n\tformula = \"\" + formula;\n\treturn {\n\t\tformula,\n\t\tpriority: 1,\n\t\ttarget: \"ac\",\n\t\tsubTarget: \"nac\",\n\t\tmodifier: \"size\",\n\t};\n};\n\nconst createSpeedChange = (formula, subTarget) => {\n\tformula = \"\" + formula;\n\treturn {\n\t\tformula,\n\t\tpriority: 1,\n\t\ttarget: \"speed\",\n\t\tsubTarget,\n\t\tmodifier: \"size\",\n\t};\n};\n\nconst createBuffChanges = (name) => {\n\tconst creature = transformationOptions[name];\n\tconst bulking = mediumOrBigger(creature.size);\n\tlet buffLevel = null;\n\n\tconst changes = [];\n\n\tif (bulking) {\n\t\tbuffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\n\t}\n\telse {\n\t\tbuffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\n\t}\n\n\tswitch (creature.spellSource.toLowerCase()) {\n\t\tcase \"beast shape\": {\n\t\t\tconst mainBonus = buffLevel * 2;\n\t\t\tconst nacBonus = buffLevel * 2;\n\t\t\tconst penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\n\t\t\tconst mainBonusAbility = bulking ? \"str\" : \"dex\";\n\t\t\tconst penaltyAbility = bulking ? \"dex\" : \"str\";\n\n\t\t\tchanges.push(createAbilityChange(mainBonus, mainBonusAbility));\n\t\t\tchanges.push(createAbilityChange(penalty, penaltyAbility));\n\t\t\tchanges.push(createNACChange(nacBonus));\n\t\t\tbreak;\n\t\t}\n\t\tcase \"plant shape\": {\n\t\t\tconst nacBonus = buffLevel * 2;\n\t\t\tif (bulking) {\n\t\t\t\tconst strBonus = Math.pow(2, buffLevel);\n\t\t\t\tconst conBonus = Math.max(2, buffLevel / 2);\n\t\t\t\tconst penalty = -(buffLevel > 2 ? 2 : 0);\n\n\t\t\t\tchanges.push(createAbilityChange(strBonus, \"str\"));\n\t\t\t\tchanges.push(createAbilityChange(conBonus, \"con\"));\n\t\t\t\tchanges.push(createAbilityChange(penalty, \"dex\"));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst conBonus = buffLevel * 2;\n\t\t\t\tchanges.push(createAbilityChange(conBonus, \"con\"));\n\t\t\t}\n\t\t\tchanges.push(createNACChange(nacBonus));\n\t\t\tbreak;\n\t\t}\n\t\tcase \"elemental body\": {\n\t\t\tif (name === \"Air Elemental\") {\n\t\t\t\tchanges.push(createAbilityChange(4, \"str\"));\n\t\t\t\tchanges.push(createAbilityChange(6, \"dex\"));\n\t\t\t\tchanges.push(createNACChange(4));\n\t\t\t\tchanges.push(createSpeedChange(120, \"flySpeed\"));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tui.notifications.error(\n\t\t\t\t`Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\n\t\t\t);\n\t\t}\n\t}\n\n\treturn changes;\n};\n\nconst createWildshapeBuff = async (caster, data) => {\n\tconst itemData = foundry.utils.mergeObject({\n\t\ttype: \"buff\",\n\t\tname: \"Wild Shape (Auto)\",\n\t\tsystem: { subType: \"temp\", level: 1 },\n\t}, data);\n\t\t// Get templates\n\tconst [wsbuff] = await caster.createEmbeddedDocuments(\"Item\", [itemData]);\n\treturn wsbuff;\n};\n\nconst getWildshapeBuff = (caster) => caster.itemTypes.buff.find(i => i.name === \"Wild Shape (Auto)\");\n\nconst transform = async (caster, token, name) => {\n\t// Save original form\n\tif (!caster.getFlag(\"pf1\", \"wildshape\")) {\n\t\tconst originalData = {\n\t\t\timage: caster.prototypeToken.texture.src,\n\t\t\tsize: caster.system.traits.size,\n\t\t};\n\t\tawait caster.setFlag(\"pf1\", \"wildshape\", { originalData });\n\t}\n\n\t// Transform\n\tconst creature = transformationOptions[name];\n\tconst changes = createBuffChanges(name);\n\n\tlet buff = getWildshapeBuff(caster);\n\tif (!buff) buff = await createWildshapeBuff(caster, { system: { changes, active: true } });\n\n\tawait caster.update({ \"system.traits.size\": sizeTranslation[creature.size] });\n\tawait token.document.update({\n\t\ttexture: { src: `${imageFolder}/${name}.png` },\n\t\t...createSizeObject(pf1.config.tokenSizes[sizeTranslation[creature.size]]),\n\t});\n};\n\nconst revertForm = async (caster, token) => {\n\tconst originalData = caster.getFlag(\"pf1\", \"wildshape\")?.originalData;\n\tawait getWildshapeBuff(caster).setActive(false);\n\tif (originalData) {\n\t\tawait caster.update({ \"system.traits.size\": originalData.size, \"flags.pf1.-=wildshape\": null });\n\t\tawait token.document.update({\n\t\t\ttexture: { src: originalData.image },\n\t\t\t...createSizeObject(pf1.config.tokenSizes[originalData.size]),\n\t\t});\n\t}\n};\n\nif (canvas.tokens.controlled.length !== 1) return void ui.notifications.warn(\"Select a token.\");\n\nconst buttons = Object.keys(transformationOptions).map((optionName) => ({\n\tlabel: optionName,\n\tcallback: () => transform(token.actor, token, optionName),\n}));\n\nif (token.actor.getFlag(\"pf1\", \"wildshape\")) {\n\tbuttons.push({\n\t\tlabel: \"Revert\",\n\t\ticon: `<i class=\"fas fa-user\"></i>`,\n\t\tcallback: () => revertForm(token.actor, token),\n\t});\n}\n\nDialog.wait({\n\ttitle: \"Wild Shape\",\n\tcontent: \"Choose creature.\",\n\tbuttons,\n});"
img: systems/pf1/icons/skills/green_27.jpg
name: Wild Shape
scope: global
sort: 0
type: script
