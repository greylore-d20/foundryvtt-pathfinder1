image: node

variables:
  # Name of the package; the build directory will be renamed to this, so the name should be free
  # in the repo's root dir!
  PACKAGE_NAME: pf1
  PACKAGE_TYPE: system
  PACKAGE_REGISTRY_URL: $CI_API_V4_URL/projects/$CI_PROJECT_ID/packages/generic/$PACKAGE_NAME
  # Directory into which package will be built, and from which the zip will be created
  BUILD_DIRECTORY: dist
  # API URL of the project
  PROJECT_API_URL: "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}"
  # Rich text variables
  INFO: \e[36m
  CLEAR: \e[0m

stages:
  - check
  - labels
  - build
  - prepare-release
  - release
  - publish

# Anchor variable to install npm cache
cache: &global_cache
  paths:
    - .npm

# Anchor script to install package dependencies with npm ci, using cache
.npm-ci: &npm-ci
  - npm ci --cache .npm --prefer-offline

# Run ESLint in error-only mode
lint:
  stage: check
  before_script:
    - *npm-ci
  script:
    - npm run lint:ci
  cache:
    <<: *global_cache

# Run prettier check
format:
  stage: check
  before_script:
    - *npm-ci
  script:
    - npm run format:check
  cache:
    <<: *global_cache

# Add i18n labels if language files were updated
i18n-labels:
  stage: labels
  rules:
    # Only run for MRs which update language files
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - "lang/*.json"
  script:
    - echo -e "${INFO}Adding i18n label...${CLEAR}"
    - >
      curl --fail-with-body
      --location "${PROJECT_API_URL}/merge_requests/${CI_MERGE_REQUEST_IID}"
      --request PUT
      --header "Content-Type: application/json"
      --header "PRIVATE-TOKEN: ${LABELS_AUTOMATION_TOKEN}"
      --data "{
        \"add_labels\": \"i18n::Key Changes\"
      }"

# Add Compendium labels if compendium files were updated
compendium-labels:
  stage: labels
  rules:
    # Only run for MRs which update compendium files
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - "packs/*.yaml"
  script:
    - echo -e "${INFO}Adding compendium label...${CLEAR}"
    - >
      curl --fail-with-body
      --location "${PROJECT_API_URL}/merge_requests/${CI_MERGE_REQUEST_IID}"
      --request PUT
      --header "Content-Type: application/json"
      --header "PRIVATE-TOKEN: ${LABELS_AUTOMATION_TOKEN}"
      --data "{
        \"add_labels\": \"Compendium\"
      }"

# Generate manifest links, build dist directory
build:
  stage: build
  before_script:
    - *npm-ci
    - apt-get --yes update
    - apt-get --yes install jq
  script:
    - TEMP_MANIFEST=$(mktemp)
    - |
      jq '.version = $version | .url = $url | .manifest = $manifest | .download = $download' \
      --arg version "${CI_COMMIT_TAG:1}" \
      --arg url "$CI_PROJECT_URL" \
      --arg manifest "$CI_PROJECT_URL/-/releases/permalink/latest/downloads/$PACKAGE_TYPE.json" \
      --arg download "$CI_PROJECT_URL/-/releases/$CI_COMMIT_TAG/downloads/$PACKAGE_NAME.zip" \
      public/$PACKAGE_TYPE.json > $TEMP_MANIFEST
    - mv $TEMP_MANIFEST public/$PACKAGE_TYPE.json
    - npm run build
    - mv $BUILD_DIRECTORY $PACKAGE_NAME
  cache:
    <<: *global_cache
  artifacts:
    paths:
      - $PACKAGE_NAME
    expire_in: 1 week
  # Run for version tags to prepare release, and for MRs to check successful build
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+(\.[0-9]+)+$/'

# Build docs from master branch
pages:
  stage: build
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
  cache:
    <<: *global_cache
  before_script:
    - *npm-ci
    - npm run link jsconfig
  script:
    - mv public vite-public
    - npm run docs
    - mv docs public
  artifacts:
    paths:
      - public

# Publish artifacts to package registry and generate release notes from changelog
# Link for regex: https://regex101.com/r/OyDskw/1, has to be verified manually in ripgrep
publish_artifacts:
  stage: prepare-release
  image: alpine:latest
  needs:
    - build
  before_script:
    - apk update
    - apk add zip curl ripgrep
  script:
    - cd $PACKAGE_NAME
    - zip -r ../$PACKAGE_NAME.zip .
    - cd ..
    - |
      echo "Publishing $PACKAGE_NAME $CI_COMMIT_TAG to $PACKAGE_REGISTRY_URL"
      curl --header "JOB-TOKEN: $CI_JOB_TOKEN" --upload-file $PACKAGE_NAME.zip "$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_NAME.zip"
      curl --header "JOB-TOKEN: $CI_JOB_TOKEN" --upload-file $PACKAGE_NAME/$PACKAGE_TYPE.json "$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_TYPE.json"
    - echo "**Manifest URL:** $CI_PROJECT_URL/-/releases/$CI_COMMIT_TAG/downloads/$PACKAGE_TYPE.json" > recent-changes.md
    - echo "" >> recent-changes.md
    - echo "$(rg -U --multiline-dotall '(?P<latest>^[#]{2}\sv?\d.*?)(?:\n^[#]{1,3}\sv?\d.*)' -r '$latest' CHANGELOG.md)" >> recent-changes.md
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+(\.[0-9]+)+$/'
  artifacts:
    paths:
      - recent-changes.md
    expire_in: 1 week

# Create release on GitLab, including release notes and attached links to the zip file and this version's manifest
release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - publish_artifacts
  rules:
    - if: '$CI_COMMIT_TAG =~ /^v[0-9]+(\.[0-9]+)+$/'
  script:
    - |
      release-cli create --name "Release ${CI_COMMIT_TAG:1}" \
      --description "$(cat recent-changes.md)" --tag-name $CI_COMMIT_TAG \
      --assets-link "{\"name\":\"$PACKAGE_NAME.zip\",\"url\":\"$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_NAME.zip\",\"filepath\":\"/$PACKAGE_NAME.zip\",\"link_type\":\"package\"}" \
      --assets-link "{\"name\":\"$PACKAGE_TYPE.json\",\"url\":\"$PACKAGE_REGISTRY_URL/$CI_COMMIT_TAG/$PACKAGE_TYPE.json\",\"filepath\":\"/$PACKAGE_TYPE.json\",\"link_type\":\"other\"}"
