{
  "name": "Wild Shape",
  "type": "script",
  "scope": "global",
  "command": "// Author: @Adam\n\n// SETUP NEEDED: for each transformation option you want, please enter it as below\n// you also need to set imageFolder to the location of where you store your tokens.\n// token art is selected by name & as a png, so for example the image for Bat is located at 'worlds/golarion/tokens/Bestiary/Bat.png'\n\n// support for elemental body is not complete yet - only air elemental is hardcoded\n\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\n\nconst transformationOptions = {\n  Bat: {\n    size: \"diminutive\",\n    spellSource: \"beast shape\",\n  },\n  \"Giant Squid\": {\n    size: \"huge\",\n    spellSource: \"beast shape\",\n  },\n  Tendriculos: {\n    size: \"huge\",\n    spellSource: \"plant shape\",\n  },\n  \"Air Elemental\": {\n    size: \"huge\",\n    spellSource: \"elemental body\",\n  },\n};\n\nconst sizes = [\n  \"diminutive\",\n  \"tiny\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"huge\",\n  \"gargantuan\",\n  \"colossal\",\n];\n\nconst sizeTranslation = {\n  fine: \"fine\",\n  diminutive: \"dim\",\n  tiny: \"tiny\",\n  small: \"sm\",\n  medium: \"med\",\n  large: \"lg\",\n  huge: \"huge\",\n  gargantuan: \"grg\",\n  colossal: \"col\",\n};\n\nconst createSizeObject = ({ w, h, scale }) => {\n  return {\n    width: w,\n    height: h,\n    scale,\n  };\n};\n\nconst mediumOrBigger = (size) => {\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\n};\n\nconst createAbilityChange = (formula, subTarget) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"ability\",\n    subTarget,\n    modifier: \"size\",\n  };\n};\n\nconst createNACChange = (formula) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"ac\",\n    subTarget: \"nac\",\n    modifier: \"size\",\n  };\n};\n\nconst createSpeedChange = (formula, subTarget) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"speed\",\n    subTarget,\n    modifier: \"size\",\n  };\n};\n\nconst createBuffChanges = (name) => {\n  const creature = transformationOptions[name];\n  const bulking = mediumOrBigger(creature.size);\n  let buffLevel = null;\n\n  const changes = [];\n\n  if (bulking) {\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\n  } else {\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\n  }\n\n  switch (creature.spellSource.toLowerCase()) {\n    case \"beast shape\": {\n      const mainBonus = buffLevel * 2;\n      const nacBonus = buffLevel * 2;\n      const penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\n      const mainBonusAbility = bulking ? \"str\" : \"dex\";\n      const penaltyAbility = bulking ? \"dex\" : \"str\";\n\n      changes.push(createAbilityChange(mainBonus, mainBonusAbility));\n      changes.push(createAbilityChange(penalty, penaltyAbility));\n      changes.push(createNACChange(nacBonus));\n      break;\n    }\n    case \"plant shape\": {\n      const nacBonus = buffLevel * 2;\n      if (bulking) {\n        const strBonus = Math.pow(2, buffLevel);\n        const conBonus = Math.max(2, buffLevel / 2);\n        const penalty = -(buffLevel > 2 ? 2 : 0);\n\n        changes.push(createAbilityChange(strBonus, \"str\"));\n        changes.push(createAbilityChange(conBonus, \"con\"));\n        changes.push(createAbilityChange(penalty, \"dex\"));\n      } else {\n        const conBonus = buffLevel * 2;\n        changes.push(createAbilityChange(conBonus, \"con\"));\n      }\n      changes.push(createNACChange(nacBonus));\n      break;\n    }\n    case \"elemental body\": {\n      if (name === \"Air Elemental\") {\n        changes.push(createAbilityChange(4, \"str\"));\n        changes.push(createAbilityChange(6, \"dex\"));\n        changes.push(createNACChange(4));\n        changes.push(createSpeedChange(120, \"flySpeed\"));\n      }\n      break;\n    }\n    default: {\n      ui.notifications.error(\n        `Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\n      );\n    }\n  }\n\n  return changes;\n};\n\n\nconst createWSBuff = async (caster, data) => {\n  const itemData = foundry.utils.mergeObject({\n    type: \"buff\",\n    name: \"Wild Shape (Auto)\",\n    system: { subType: \"temp\", level: 1 },\n  }, data);\n  // Get templates\n  await caster.createEmbeddedDocuments(\"Item\", [itemData]);\n  return getWSBuff(caster);\n};\n\nconst getWSBuff = (caster) => {\n  return caster.items.find(\n    (i) => i.type === \"buff\" && i.name === \"Wild Shape (Auto)\"\n  );\n};\n\nconst transform = async (caster, token, name) => {\n  const creature = transformationOptions[name];\n  const changes = createBuffChanges(name);\n\n  let buff = getWSBuff(caster);\n  if (!buff) buff = await createWSBuff(caster, { \"system.changes\": changes, \"system.active\": true });\n\n  await token.document.update(\n    foundry.utils.mergeObject(\n      { texture: { src: `${imageFolder}/${name}.png` } },\n      createSizeObject(CONFIG.PF1.tokenSizes[sizeTranslation[creature.size]])\n    )\n  );\n  await caster.update({ \"system.traits.size\": sizeTranslation[creature.size] });\n};\n\nconst revertForm = async (caster, token) => {\n  const originalData = caster.flags.pf1?.wildshape?.originalData;\n  await getWSBuff(caster).update({ \"system.active\": false });\n  if (originalData) {\n    await caster.update({ \"system.traits.size\": originalData.size, \"flags.pf1.-=wildshape\": null });\n    await token.document.update(\n      foundry.utils.mergeObject(\n        { texture: { src: originalData.image } },\n        createSizeObject(CONFIG.PF1.tokenSizes[originalData.size])\n      )\n    );\n  }\n};\n\nconst tokens = canvas.tokens.controlled;\n\nif (tokens.length !== 1) {\n  ui.notifications.warn(\"Select a token.\");\n} else {\n  const token = tokens[0];\n  const actor = token.actor;\n  const caster = actor;\n\n  if (!Object.keys(caster.flags.pf1?.wildshape ?? {}).includes(\"originalData\")) {\n    const originalData = {\n      image: caster.prototypeToken.texture.src,\n      size: caster.system.traits.size,\n    };\n    await caster.update({ \"flags.pf1.wildshape.originalData\": originalData });\n  }\n\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\n    label: optionName,\n    callback: () => transform(actor, token, optionName),\n  }));\n  buttons[\"Revert\"] = {\n    label: \"Revert\",\n    icon: '<i class=\"fas fa-user\"></i>',\n    callback: () => revertForm(actor, token),\n  };\n\n  new Dialog({\n    title: \"Wild Shape\",\n    content: \"Choose creature.\",\n    buttons: buttons,\n  }).render(true);\n}",
  "author": "ZuWclcb9BUy2aZSN",
  "img": "systems/pf1/icons/skills/green_27.jpg",
  "_id": "GyuHEoeLTtLZCvhS",
  "sort": 0
}
